# This file is autogenerated
comm_speed=2000000
erase_as_needed = True
reset_delay = 0
has_reset = True
show_output = False
log_level = 0
has_connected = False
comm_iface = True # default to swd

def _begin_debug_session():
    ensure_connect()
    if not live_connect:
        reset_and_halt()
    cache_onDebugStart()

def _begin_communication_session(): 
    global log_level,show_output,reset_delay, target_was_reset, has_reset, has_connected, live_connect
    log_level    = settings.getNumeric("script.log_level",log_level)
    show_output  = settings.getBool("script.show_output",show_output)
    has_reset  = settings.getBool("script.has_reset",has_reset)
    reset_delay = settings.getNumeric("script.reset_delay",reset_delay)
    live_connect = True
    has_connected = False
    target_was_reset = False

    dev.SetApiLogging(log_level)
    log.setShowOutput(show_output)

    global comm_iface, comm_speed, erase_as_needed
    comm_iface = settings.getString("communication.interface", "swd") == "swd"
    comm_speed = settings.getNumeric("communication.frequency", comm_speed)
    erase_as_needed = True  

    init_mem_handlers()

def _end_communication_session(): 
    global has_connected
    dev.Disconnect()
    has_connected = False


def onShowPropsDFP2(t):
    ide.addBooleanProperty(t,"arm.use_vtor" , "*|programoptions|programoptions.eraseb4program","Set PC and SP to VTOR","After reset, force PC and SP to the entries defined by the VTOR", False)
    ide.addTextProperty(t,"arm.vtor_adr" , "*|programoptions|programoptions.eraseb4program","VTOR table or numerical address", "Enter address of vector table", "exception_table")
    ide.addEnumProperty(t,"programoptions.smart.program", "*|programoptions|programoptions.eraseb4program","Use smart programming", "Use smart programming to optimize programming speed", "When debugging only", 
                        "When debugging only|When debugging only|n/a\n"
                        "For debugging and programming|For debugging and programming|n/a\n"
                        "Never|Never|n/a")
    ide.addPropCategory(t,"diagnostics" , "*|toolpack", "Diagnostics")
    ide.addBooleanProperty(t,"script.show_output" , "*|diagnostics|*","Output diagnostic logging","Show diagnostic text in the Output window", False)
    ide.addTextProperty(t,"script.log_level" , "*|diagnostics|*","Diagnostic log level","Set diagnostic level (usually 0 1 or 3)", "1")
    ide.addTextProperty(t,"script.reset_delay" , "*|diagnostics|*","Additional delay after reset","Enter additional RST settling delay in msec", "0")
    ide.addBooleanProperty(t,"script.has_reset" , "*|diagnostics|*","Uncheck if RESET line is not wired","Normally checked. Uncheck if the target does not have RST connected to the debugger", True)
    ide.addTextProperty(t, "loader.board_file", "*|programoptions|**","Board file path","Set the path of board file", "${ProjectDir}/board.xboard")

def print_dhcsr_v(t, d):
    log.info(t + arm.getDHCSRString(d))

def print_dhcsr(text):
    try:
        d = dev.Read32(arm.DHCSR)
        print_dhcsr_v(text, d)
        return d
    except:
        log.log("DHCSR is unreadable")
        return 0

def _debug_read(mt, start, length, data):
    cache_onDataRead(start, length)
    try:
        dev.Read(start, data, 0, length)
    except:
        for i in range(len(data)):
            try:
                dev.Read(start + i, data, i, 1)
            except:
                data[i] = b'?'
                dev.Delay(reset_delay)
        log.info("Debug: an error occurred while reading address 0x%x length 0x%0x" % (start, length))

def _debug_write(mt, start, length, data):
    if str(mt) == "Pgm":
        cache_invalidateInstrCache()
        try:
            _flash_write(start, length, data, True)
        except:
            for i in range(len(data)):
                try:
                    _flash_write(start + i * 4, 1, data[i], True)
                except:
                    dev.Delay(reset_delay)
            log.info("Debug: an error occurred while writing address 0x%x length 0x%0x" % (start, length))
        return

    cache_onDataWrite(start, length)
    try:
        dev.Write(start, data, 0, length)
    except:
        for i in range(len(data)):
            try:
                dev.Write(start + i, data, i, 1)
            except:
                dev.Delay(reset_delay)
        log.info("Debug: an error occurred while writing address 0x%x length 0x%0x" % (start, length))

def debug_write_supports_flash():
    return 1

def _get_pc():
    try:
        pc = dev.ReadReg64(15)
    except:
        log.error("get_pc returned error")
        return 0
    return pc
    
def _mem_read(start, length, data):
    dev.Read(start, data, 0, length)

def _mem_write(start, length, data):
    dev.Write(start, data, 0, length)

def _run_target():
    cache_onRun()
    wdt_onRun()
    dev.Write32(arm.DHCSR, 0xa05f0001)  # DBGKEY | C_DEBUGEN

def _halt_target():
    dev.Write32(arm.DHCSR, 0xa05f0003)  # DBGKEY | C_DEBUGEN | C_HALT

def _step_target():
    cache_onRun()
    wdt_onRun()
    dev.Write32(arm.DHCSR, 0xa05f000b)  # DBGKEY | C_DEBUGEN | C_HALT | C_MASKINTS
    dev.Write32(arm.DHCSR, 0xa05f000d)  # DBGKEY | C_DEBUGEN | C_STEP | C_MASKINTS
    dev.Write32(arm.DHCSR, 0xa05f0003)  # DBGKEY | C_DEBUGEN | C_HALT
    cache_onStop()
    wdt_onHalt()

def _set_pc(pc):
    dev.WriteReg64(15, pc)

def print_byte_array(text, array, index, size):
    string = text
    for i in range(size):
        string += " %x" % array[i+index]
    log.info(string)

g_is_running = True
dhcsr = 0
def _is_target_running():
    global g_is_running, dhcsr
    dhcsr = dev.Read32(arm.DHCSR)
    state = 0 == (dhcsr & 0x20000)#BIT17 : S_HALT
    if state != g_is_running:
        log.info("Debug: target is now running" if state else "Debug: target has halted")
        g_is_running = state 
    if not g_is_running:
        cache_onStop()
        wdt_onHalt()
    return g_is_running

def _reset_target(): 
    reset_and_halt()

def ensure_connect():
    global has_connected
    if has_connected:
        return
    dev.Connect(comm_iface, comm_speed)
    has_connected = True

def _end_debug_session(): 
    #disable hw bp
    fpb = dev.Read32(0xe0002000)
    if 0 != (fpb & 1):
        dev.Write32(0xe0002000,2|(fpb&0xFFFFfffe))
    run_target()


def set_sw_bp_gen(address, erase_size, instruction, flags):  #mplab
    global erase_as_needed
    log.debug("Debug: set/reset bp at address 0x%0x, store instructions 0x%0x, flags = 0x%0x" % (address, instruction, flags))
    if address >= 0x20000000:
        erase_size = 4 
    else:
        clear_and_report_flash_error()


    erase_page_start = address & ~(erase_size-1)
    address_in_erase_page = address & (erase_size-1)

    data = bytearray(erase_size)
    cache_invalidateInstrCache()
    dev.Read(erase_page_start, data, 0, erase_size)
    return_value = data[address_in_erase_page] | (data[address_in_erase_page+1] << 8)

    # Insert software breakpoint instruction in the data
    data[address_in_erase_page] = instruction & 0xFF
    data[address_in_erase_page+1] = (instruction >> 8) & 0xFF

    if erase_size == 4:
        dev.Write(erase_page_start, data, 0, erase_size)
    else:
        erase_as_needed = True
        prog_write("Pgm", erase_page_start, erase_size, data)
    return return_value

# device specific functions


def dap_Read8(adr):
    return dev.Read8(adr)

def dap_Write8(adr,val):
    return dev.Write8(adr,val)

def dap_Read16(adr):
    return dev.Read16(adr)

def dap_Write16(adr,val):
    return dev.Write16(adr,val)

def dap_Read32(adr):
    return dev.Read32(adr)

def dap_Write32(adr,val):
    return dev.Write32(adr,val)

def dap_Read(adr,b,o,l):
    return dev.Read(adr,b,o,l)

def set_reset_pin(level):
    dev.Pins(0 if level==0 else dev.RESET, dev.RESET, 1000)
    if reset_delay > 0:
        dev.Delay(reset_delay)
    
def set_clk_pin(level):
    dev.Pins(0 if level==0 else dev.SWCLK, dev.SWCLK, 100)


class arm_const:
    DHCSR = 0xE000EDF0
    DEMCR = 0xE000EDFC
    AIRCR = 0xE000ED0C

    def getDHCSRString(self, num):
        return str(num)

def set_globals(dev_copy, utils_copy, settings_copy, device_copy, log_copy):
    global dev, utils, settings, device, log, arm
    arm = arm_const()
    dev = dev_copy
    utils = utils_copy
    settings = settings_copy
    device = device_copy
    log = log_copy

def set_globals2(dev_copy, utils_copy, settings_copy, device_copy, log_copy, arch):
    global architecture
    architecture = arch
    set_globals(dev_copy, utils_copy, settings_copy, device_copy, log_copy)

def _hold_in_reset(): 
    global has_reset, has_connected

    if not has_reset:
        alt_hold_in_reset()
        return
    log.info("Prog: Hold in reset")
    set_reset_pin(0)
    #  The debugger needs to stay connected to actively keep the reset line low.
    has_connected = False # Pins ends debug session, so a reconnect will be neeeded


def alt_hold_in_reset(): 
    # Alternative if RESET pin is not connected to debugger
    log.info("Prog: Hold in reset , no reset line")
    reset_and_halt()

def _release_from_reset():
    global reset_delay
    global has_reset
    if not has_reset:
        log.info("Prog: Release from reset (soft reset)")
        reset_and_halt()
        run_target()
        return
    log.info("Prog: Release from reset (float reset line)")
    set_reset_pin(0)
    set_reset_pin(1)

def alt_release_from_reset():
    log.info("Prog: Release from reset, no reset line")
    dev.Write32(dev.AIRCR, 0x05fa0004)  # VECTKEY | SYSRESETREQ
# to generate the crc binary, run build.bat in the mplab packs repo  mplab\packs\sources\local\tools.mdbcore.sam\standalone\crc_analyzer\build.bat
# the bytes are generated to compute_sector_crc.py and should be copy pasted into here

crcCode = (
    248,181,31,0,4,0,13,0,22,0,0,240,15,248,0,47,9,208,191,0,231,25,40,0,49,0,0,240,75,248,1,196,
173,25,188,66,247,209,0,190,0,32,248,189,48,181,128,37,0,33,1,34,29,76,30,72,124,68,109,0,75,8,10,66,
0,208,67,64,26,66,45,209,91,8,26,66,39,209,91,8,26,66,33,209,91,8,26,66,27,209,91,8,26,66,21,209,
91,8,26,66,15,209,91,8,26,66,5,209,91,8,1,49,8,196,169,66,226,209,48,189,91,8,67,64,1,49,8,196,
169,66,219,209,247,231,91,8,67,64,237,231,91,8,67,64,231,231,91,8,67,64,225,231,91,8,67,64,219,231,91,8,
67,64,213,231,91,8,67,64,207,231,192,70,172,0,0,0,32,131,184,237,112,181,0,41,18,208,2,0,65,24,1,32,
255,37,8,78,64,66,126,68,19,120,4,10,67,64,43,64,155,0,152,89,1,50,96,64,145,66,245,209,192,67,112,189,
0,32,252,231,30,0,0,0,

    )

def _call_function_and_wait( sp, pc, r0, r1, r2, r3, timeout):
    dev.WriteReg64(arm.SP, sp)
    dev.WriteReg64(arm.PC, pc)

    dev.WriteReg64(0,r0)
    dev.WriteReg64(1,r1)
    dev.WriteReg64(2,r2)
    dev.WriteReg64(3,r3)
    dev.Write32(arm.DEMCR, 0x01000001)
    run_target()
    while timeout > 0:
        if not is_target_running():
            break
        dev.Delay(20000)
        timeout -= 20000
    
    dev.Write32(arm.DEMCR, 0x01000000)
    if timeout <= 0:
        raise "Applet execution timed out"

def compute_crcs( applet_addr, mailboxAdr, prg_addr, size, blk_size, sectors):
    an_array = bytearray(crcCode)
    dev.Write(applet_addr, an_array,0, len(an_array))
    _call_function_and_wait(applet_addr, applet_addr, mailboxAdr, prg_addr, blk_size, len(sectors), timeout=10000000)
    data = bytearray(4*len(sectors))
    dev.Read(mailboxAdr, data, 0, len(data)) 
    for idx in range(len(sectors)):
        crc = data[4*idx] + 256 * data[4*idx+1] + 256*256 * data[4*idx+2] + 256*256*256 * data[4*idx+3]
        # log.info("crc %d 0x%x 0x%x" % (idx, sectors[idx] , crc ))
        sectors[idx]= sectors[idx] == crc 

def get_crc_skiplist(applet_addr, prg_data, prg_addr, size, blk_size):
    smartSettings = settings.getString("programoptions.smart.program","Never")
    if "Never" == smartSettings or (not is_debug_build and "When debugging only" == smartSettings):
        return []
    crc_check = [0]*(size/blk_size)
    for idx in range(len(crc_check)):
        crc_check[idx] = utils.crc32(prg_data, blk_size*idx, blk_size) 
    compute_crcs(applet_addr, applet_addr + 0x800, prg_addr, size, blk_size, crc_check)
    if dhcsr & 0x02000000 : 
        log.error("A (watchdog?) reset occured while the CRC smart programming applet was running. To use smart programming you must disable the WDT in the fuse section.")
        return []
    return crc_check
dsu_statusa = 0x41002101
dsu_ctrl = 0x41002100
    
class nvm:
    page_size = 64
    erase_size = 256
    aux_size = 256
    cmdReg = 0x41004000
    cfgReg  = 0x41004004
    stsReg = 0x41004018
    intReg = 0x41004014
    adrReg = 0x4100401c
    AUX_ERASE = 0xA505
    ROW_ERASE = 0xA502
    RWW_ERASE = 0xA51A
    RWW_WRITE = 0xA51C
    erase_time = 100
    UROW = 0x00804000
    RWW = 0x00400000
    SSB  = 0xA545

def cache_invalidate():
    nvm_cmd(0xA546,20)
def cache_onDebugStart():
    cache_invalidate()
def cache_onStop():
    cache_invalidate()

def cache_onRun():
    pass    
def cache_onDataRead(adr,size):
    pass #done in onStop
def cache_onDataWrite(adr,size):
    pass #done in onStop
def cache_invalidateInstrCache():
    pass #done in onStop

def wdt_onRun():
    pass
def wdt_onHalt():
    pass

def is_nvm_ready():
    intFlag = dap_Read8(nvm.intReg)
    isReady = 0 != (intFlag & 1)
    isError = 0 != (intFlag & 2)
    if not isError:
        return isReady

    status = dap_Read16(nvm.stsReg)
    log.error("NVMCtrl error bits set! (STATUS = 0x%X, INTFLAG = 0x%X)" % (status, intFlag))
    dap_Write16(nvm.stsReg, status | 0x001E) # clear Error and Load bits in Status
    dap_Write8(nvm.intReg, intFlag | 2) # clear Error bit in INTFLAG
    err = " error"
    if status & 4:
        err = " PROGE " + err
    if status & 8:
        err = " LOCKE " + err
    if status & 16:
        err = " NVME " + err
    raise Exception("The NVM controller reports an " + err)

def clear_and_report_flash_error():
    try:
        is_nvm_ready()
    except:
        log.error("NVM controller is in an error state while setting a swbp. Clearing the error")

# global variable keeps previous value of flash cfg register while programming
prevCfgReg = 0x0

def cfg_nvmctrl():
    global prevCfgReg
    prevCfgReg = dap_Read32(nvm.cfgReg)
    newCfgReg = (prevCfgReg & 0xFFFFFF61) | 0x1e  # 15 wait states and clear MANW
    if newCfgReg != prevCfgReg:
        dap_Write32(nvm.cfgReg, newCfgReg)

def restore_nvmctrl():
    #log.debug("reset_cfg_word: prevCfgReg = %x" % prevCfgReg)
    dap_Write32(nvm.cfgReg, prevCfgReg)

def erase_row(addr,cmd):
    dap_Write32(nvm.adrReg,addr >> 1)
    nvm_cmd (cmd, 20)
def _begin_programming_operation():
    global erase_as_needed,has_reset
    erase_as_needed = True
    
    reset_extension()
    if has_reset:
        statusa = dev.Read8(dsu_statusa) # verify CRSTEXT is set
        if 0 == (statusa & 2): #STATUSA.CRSTEXT
            log.error("Device could not enter reset extension, check cap on RST line")
            raise Exception("Reset error.")
        else:
            log.info("Device entered reset extension")
    try:
        reset_and_halt()  # clear CRSTEXT
    except:
        pass

def _erase_internal():
    global set_security_bit
    smartSettings = settings.getString("programoptions.smart.program","Never")
    if "Never" == smartSettings or (not is_debug_build and "When debugging only" == smartSettings):
        pass
    else:
        return

    set_security_bit = False
    chip_erase()
    reset_extension() # reset_extension is required after a chip erase when chip(e.g. SAME54) was secured
    reset_and_halt()
    
    if settings.getBool("x.erase.clearprot", True):
        restoreBOOTPROTandNVMCTRLREGIONLOCKS()

def reset_and_halt():
    halt_target()
    dev.Write32(arm.DEMCR, 0x01000001) # TRCENA  | VC_CORERESET
    dev.Write32(arm.AIRCR, 0x05fa0004) # VECTKEY | SYSRESETREQ
    n = 0
    retries = 10
    seenReset = False
    while n<retries:
        dhcsr = dev.Read32(arm.DHCSR)
        #print_dhcsr_v("arm.DHCSR",dhcsr)
        if (dhcsr & 0x02000000): # wait for S_RESET_ST
            seenReset=True
            dev.Write32(arm.DHCSR, 0xa05f0003) # DBGKEY|C_HALT|C_DEBUGEN
            dev.Write8(dsu_statusa, 2) # release the cpu 0x41002101,0x2  STATUSA.CRSTEXT
            dhcsr = print_dhcsr("Cleared CRSTEXT")
        hasHalted = 0 != (dhcsr & 0x20000) # S_HALT
        if seenReset:
            if hasHalted: # wait for S_HALT
                break
        dev.Delay(100000)
        n=n+1
    dev.Write32(arm.DEMCR, 0x01000000) # TRCENA
    if n==retries:
        raise Exception("The device did not come out of reset")

def reconnectAfterExtension():
    global has_connected
    has_connected = False # reset extension kills the OCD connection
    ensure_connect()

def write_row(adr, ofs, data,len):
    dev.Write(adr, data, ofs , len)
    wait_nvm_ready(10)

def _prog_write_internal(type_of_mem, address, length, data): 
    global erase_as_needed

    if _handle_security_flags(address,length,data):
        return
        
    statusb = dap_Read8(dsu_ctrl + 2)
    if statusb & 1:
        raise Exception("Device is protected. A chip erase is needed to remove the protection.")

    if address >= 0x20000000:
        dev.Write(address, data, 0, length)
        return
    if address == nvm.UROW: # user page / fuses / configuration bits
        _flash_write_rng(address,length,data,nvm.AUX_ERASE,[])
        reset_and_halt()
    else:
        erase_cmd = nvm.RWW_ERASE if str(type_of_mem) == "RWW" or address >= 0x00400000 and address <= 0x00410000 else nvm.ROW_ERASE
        crc = get_crc_skiplist(0x20000100,data,address,length,nvm.erase_size)
        _flash_write_rng(address,length,data,erase_cmd if erase_as_needed else 0,crc)

def _flash_write_rng(address, length, data, erase_cmd, skip_list):
    cfg_nvmctrl()
    written = 0
    write_size = nvm.erase_size if nvm.erase_size < 1024 else nvm.page_size
    # a flash row has 'erase_size' bytes
    while written < length:
        if len(skip_list) > 0 and skip_list [written / nvm.erase_size] == 1:
            address += nvm.erase_size
            written += nvm.erase_size
            continue
        if erase_cmd != 0:
            erase_row(address, erase_cmd)
        if erase_cmd == nvm.AUX_ERASE:
            dev.Read32(address) # fix for MPLABX-4768. For the particular project provided in the Jira ticket, MPLAB need to to a read before write, otherwise the PC will be 0
        page = 0
        nPages = nvm.erase_size / write_size
        while page < nPages and written < length:
            write_row(address , written,data, min(length - written, write_size))
            address += write_size
            written += write_size
            page = page + 1
    restore_nvmctrl()

def _flash_write(address, length, data, doerase): # for swbps
    _flash_write_rng(address, length, data, nvm.ROW_ERASE,[])

def _prog_read_internal(type_of_mem, address, length, data):    
    dev.Read(address,data,0,length)

def set_sw_bp(address, instruction, flags):#mplab
    return set_sw_bp_gen(address,nvm.erase_size,instruction,flags)

def restoreBOOTPROTandNVMCTRLREGIONLOCKS():
    b=bytearray(nvm.page_size)
    dev.Read(nvm.UROW, b, 0, nvm.page_size)
    if "M0" in architecture:
        if "JH" in device and "PIC32CM" in device:
            b[0] = b[0] | 0x0F # clear BOOTPROT
        else:
            b[0] = b[0] | 0x07 # clear BOOTPROT
        b[6] = 0xFF # clear NVMCTRL_REGION_LOCKS
        b[7] = 0xFF # clear NVMCTRL_REGION_LOCKS
    elif "M4" in architecture:
        b[3] = b[3] | 0x3C # clear BOOTPROT
        b[8] = 0xFF # clear NVMCTRL_REGION_LOCKS
        b[9] = 0xFF # clear NVMCTRL_REGION_LOCKS
        b[10] = 0xFF # clear NVMCTRL_REGION_LOCKS
        b[11] = 0xFF # clear NVMCTRL_REGION_LOCKS
    prog_write("Cfg", nvm.UROW, nvm.page_size, b)
    reset_and_halt()
target_was_reset = False
debug_session  = True

def begin_communication_session(): #mplab
    log.info("Begin comm session")
    _begin_communication_session()

def end_communication_session(): #mplab
    log.info("End comm session")
    _end_communication_session()

def begin_programming_operation(): #mplab
    global debug_session
    log.info("Begin operations")
    debug_session = False
    _begin_programming_operation()

def erase(): #mplab
    log.info("Erase")
    _erase()

def prog_write(type_of_mem, address, length, data): #mplab
    log.info("Writing %08x bytes to address 0x%08x of %s memory" % (length, address, type_of_mem))
    _prog_write(type_of_mem, address, length, data)

def prog_read(type_of_mem, address, length, data): #mplab
    log.info("Reading %08x bytes from address 0x%08x of %s memory" % (length, address, type_of_mem))
    _prog_read(type_of_mem, address, length, data)

def end_of_operations():#mplab
    log.info("End of operations")
    _end_of_operations()

def begin_debug_session():  #mplab
    log.info("Debug: Init debug session")
    global debug_session
    debug_session = True
    _begin_debug_session()

def debug_read(mt, start, length, data):  #mplab
    log.info("Debug: Reading %08x bytes at start address 0x%08x (%s)" % (length, start, mt))
    _debug_read(mt, start, length, data)

def debug_write(mt, start, length, data):  #mplab
    log.info("Debug: Writing %08x bytes at start address 0x%08x (%s)" % (length, start, mt))
    _debug_write(mt, start, length, data)

def set_pc(pc):  #mplab
    log.info("Debug: set pc to 0x%08x" % pc)
    _set_pc(pc)

def get_pc():  #mplab
    pc = _get_pc()
    log.info("Debug: get_pc PC=0x%08x" % pc)
    return pc

def run_target():#mplab
    log.info("Debug: run target")
    _run_target()

def halt_target():  #mplab
    log.info("Debug: halt target")
    _halt_target()

def step_target():  #mplab
    log.info("Debug: stepping at pc 0x%08x" % get_pc())
    _step_target()

def reset_target(): #mplab
    log.info("Debug: reset")
    _reset_target()
    on_after_reset() # call autoload hook

def is_target_running():#mplab
    return _is_target_running()

def on_after_reset(): 
    if not debug_session:
        return
    if not settings.getBool("arm.use_vtor", False):
        return
    vtor_name  = settings.getString("arm.vtor_adr", "0")

    vtor = -1
    try:
        vtor = int(vtor_name,0)
    except:
        try:
            vtor=deb.GetSymbolAddress(vtor_name)
        except:
            log.error("Debug: failed to compute location of VTOR")
            return
    load_vtor(vtor) 
    pass

def load_vtor(adr):
    try:
        pc = dev.Read32(adr + 4)
        sp = dev.Read32(adr)
        set_pc(pc)
        dev.WriteReg64(arm.SP,sp)
        log.info("Setting pc=%08x and sp=%08x" % (pc, sp))
    except:
        log.error("Debug: failed to set PC and SP to contents of exception_table")

def on_program_done():
    on_after_reset()

def end_debug_session():  #mplab
    log.info("Debug: End debug session")
    _end_debug_session()

def verify_transfer(type_of_mem, address, data, length):  #mplab
    log.info("Verifying %08x bytes to address 0x%0x of %s memory" % (length, address, type_of_mem))
    _verify_transfer(type_of_mem, address, data, length)

    

def _verify_transfer(type_of_mem, address, data, length):
    if len(data) != length:
        raise Exception("The given data and length mismatch")
    d = bytearray(length)
    prog_read(type_of_mem, address, length, d)
    if str(type_of_mem) == "Cfg":
        verify_config(address, data, d, "verify")
    else:
        for i in range(length):
            if data[i] != d[i]:
                raise Exception("Verify failed for mem type {}, at address 0x{:X}".format(str(type_of_mem), address + i))

global dev_cfg_masks_bytearray
dev_cfg_masks_bytearray = None

def init_masks_as_bytearray():
    global dev_cfg_masks_bytearray
    if dev_cfg_masks_bytearray:
        return
    dev_cfg_masks_bytearray = {}
    for address, val in dev_cfg_masks.items():
        dev_cfg_masks_bytearray[address    ] = int(val      ) & 0xFF
        dev_cfg_masks_bytearray[address + 1] = int(val >> 8 ) & 0xFF
        dev_cfg_masks_bytearray[address + 2] = int(val >> 16) & 0xFF
        dev_cfg_masks_bytearray[address + 3] = int(val >> 24) & 0xFF

def verify_config(address, expected, actual, error_string_prefix):
    try:
        # older versions of MPLAB X (<=v5.45) did not pass dev_cfg_masks
        # so very_config cannot be executed
        dev_cfg_masks 
    except:
        raise Exception("{} config is not implemented".format(error_string_prefix))
    init_masks_as_bytearray()

    for index, actual_val in enumerate(actual):
        current_address = address + index
        if current_address in dev_cfg_masks_bytearray:
            mask = dev_cfg_masks_bytearray[current_address]
            expected_val = expected[index] & mask
            actual_val &= mask
            if actual_val != expected_val:
                error_string = "{} failed at address 0x{:0X}, expected 0x{:0X}, got 0x{:0X}".format(error_string_prefix, current_address, expected_val, actual_val)
                raise Exception(error_string)

def blank_check():  #mplab
    log.info("Blank check")

def blank_check_mem(type_of_mem, address, length):  #mplab
    msg.print("Blank checking %08x bytes to address 0x%0x of %s memory" % (length, address, type_of_mem))
    _blank_check_mem(type_of_mem, address, length)

def _blank_check_mem(type_of_mem, address, length):
    data = bytearray(length)
    prog_read(type_of_mem, address, length, data)
    if str(type_of_mem) == "Cfg":
        prog_read(type_of_mem, address, length, data)
        verify_config(address, data, data, "blank check")
    elif adr < 0x20000000:
        for index, x in enumerate(data):
            if x != 255:
                raise Exception("Blank failed for mem type {}, at address 0x{:X}".format(str(type_of_mem), address + index))
    else:
        log.error("Blank check, ignoring {}".format(str(type_of_mem)))

def hold_in_reset():  #mplab
    log.info("Hold in reset")
    _hold_in_reset()

def release_from_reset():  #mplab
    log.info("Release from reset")
    _release_from_reset()
    
def read_device_id():#mplab
    log.info("Read device ID")
    return _read_device_id()
def onloadDFP(ide):
    try:
        if ide.getVersion() > 0x545:
            ide.addCommand("Device actions|Set security bit", "menu_set_secbit")
            ide.addCommand("Device actions|Chip erase", "menu_chiperase")
    except:
        pass

def menu_set_secbit():
    device_action(True)

def menu_chiperase():
    device_action(False)

def device_action(set_bit):
    global connect_mode 
    if deb.Connected():
        r = msg.msg("Debugger is in use. Stop debugging and retry", "Busy")
        return
    try:
        connect_mode = 1
        deb.Connect()
    finally:
        connect_mode = 2
    try:
        reset_extension()
        if set_bit:
            statusb = dap_Read8(dsu_ctrl + 2)
            if statusb & 1:
                raise Exception("Device is protected. A chip erase is needed to remove the protection.")
            nvm_cmd(nvm.SSB,20)
            msg.msg("The security bit is now set","Set security bit")                
        else:
            chip_erase()
            msg.msg("Chip erase done", "Chip erase")
    except Exception as e:
        msg.msg(str(e),"Error")
        raise e
    except :
        msg.msg("Device might be locked. Perform a chip erase to remove the lock.","Error")
    finally:
        dev.Disconnect()
        deb.Disconnect()

def nvm_cmd(command, t):
    dap_Write16(nvm.cmdReg, command)
    wait_nvm_ready(t)

def wait_nvm_ready(t):
    while t > 0 :
        if is_nvm_ready():
            return
        dev.Delay(1000)
        t  = t - 1
    if t == 0:
        raise Exception("The NVM controller operation did not finish")

def chip_erase():
    dsu_ce = 0x10
    dap_Write8(dsu_ctrl, dsu_ce) # 0x41002100,0x10

    n = 0
    while n < nvm.erase_time:
        statusa=dap_Read8(dsu_statusa) # 0x41002101
        if statusa & 1: #statusa_done
            if statusa & 0x1c:
                log.error("DSU.STATUSA indicates an error %x"  % statusa)
                raise Exception("Erase error")
            break
        dev.Delay(100000)
        n=n+1


set_security_bit  = False 
def _handle_security_flags(address, length, data): 
    if address == 0x41004000:
        if length < 1:
            log.error("Empty security bit payload")
            return False
        global set_security_bit
        set_security_bit = data[0] != 0
        if set_security_bit:
            log.info("Will set the security bit")
        return True
    return False

def _end_of_operations():
    global erase_as_needed,set_security_bit
    erase_as_needed = True

    if set_security_bit:
        nvm_cmd(nvm.SSB,20)
        set_security_bit = False

def reset_extension():
    global reset_delay # additional delay for reset line if needed
    global has_reset

    if not has_reset:
        reconnectAfterExtension()
        return

    delay=1000  # time to  wait for analog RESET/SWCLK pins to become digitally high/low
    try:
        dev.SetInterface(dev.SWD)
    except:
        dev.Connect(comm_iface, comm_speed)
    set_reset_pin(0)
    set_reset_pin(1)
    set_reset_pin(0)
    set_clk_pin(0)
    set_reset_pin(1)
    reconnectAfterExtension()

def _read_device_id():
    return dap_Read32(0x41002118) # DSU-DID register

import os
has_samba = os.path.isfile(os.path.join("samba.py"))
if has_samba:
    import samba
from xml.dom import minidom


class MemHandlers():
    def __init__(self, board_file):
        if has_samba:
            samba.log = log
            samba.msg = msg
            samba.dev = dev
            samba.is_target_running = is_target_running
            samba.run_target = run_target
            samba.architecture = architecture
            samba.arm = arm
        self.parse_board_file(board_file)

    def parse_board_file(self, board_file):
        self.handlers = []
        xmldoc = minidom.parse(board_file)
        rangeNodes = xmldoc.getElementsByTagName("range")
        for rangeNode in rangeNodes:
            start = int(rangeNode.getAttribute("start"), 0)
            end = int(rangeNode.getAttribute("end"), 0)
            type = rangeNode.getAttribute("type")
            config = {}
            for configNode in rangeNode.childNodes:
                if configNode.nodeType == configNode.ELEMENT_NODE:
                    try:
                        config[configNode.tagName] = int(configNode.firstChild.nodeValue, 0)
                    except:
                        config[configNode.tagName] = ide.expandProjectMacros("${ProjectName}", configNode.firstChild.nodeValue).replace("\\", os.path.sep)
            if type == "samba" and has_samba:
                self.handlers.append(samba.Samba(start, end, config))
            elif type == "user":
                self.handlers.append(UserHandler(start, end, config))

    def prog_write(self, type_of_mem, address, length, data):
        log.info("Prog: Writing %d bytes to address 0x%0x of %s memory" % (length, address, type_of_mem))
        global erase_as_needed
        remainings = [[address, address + length]]
        for handler in self.handlers:
            write_start = max(address, handler.range_start)
            write_end = min(address + length, handler.range_end)
            if write_start < write_end:
                # chop the data buffer and pass it to handler and run
                if erase_as_needed:
                    handler.erase(write_start - handler.range_start, write_end - write_start)
                handler.write(write_start - handler.range_start, data[write_start - address: write_end - address])
            new_remainings = []
            for remaining in remainings:
                write_start = max(remaining[0], handler.range_start)
                write_end = min(remaining[1], handler.range_end)
                if remaining[0] < write_start < remaining[1]:
                    new_remainings.append([remaining[0], write_start])
                if remaining[0] < write_end < remaining[1]:
                    new_remainings.append([write_end, remaining[1]])
                elif write_start < write_end < remaining[0] or remaining[1] < write_start < write_end or write_start > write_end:
                    new_remainings.append(remaining)
            remainings = new_remainings
        # now write to memory ranges that are not covered by handlers
        for remaining in remainings:
            _prog_write_internal(type_of_mem, remaining[0], remaining[1] - remaining[0], data[remaining[0] - address: remaining[1] - address])

    def prog_read(self, type_of_mem, address, length, data):
        log.info("Prog: Reading %d bytes to address 0x%0x of %s memory" % (length, address, type_of_mem))
        remainings = [[address, address + length]]
        for handler in self.handlers:
            read_start = max(address, handler.range_start)
            read_end = min(address + length, handler.range_end)
            if read_start < read_end:
                # chop the data buffer and pass it to handler and run
                buffer = bytearray(read_end - read_start)
                handler.read(read_start - handler.range_start, buffer)
                data[read_start - address: read_end - address] = buffer
            new_remainings = []
            for remaining in remainings:
                read_start = max(remaining[0], handler.range_start)
                read_end = min(remaining[1], handler.range_end)
                if remaining[0] < read_start < remaining[1]:
                    new_remainings.append([remaining[0], read_start])
                if remaining[0] < read_end < remaining[1]:
                    new_remainings.append([read_end, remaining[1]])
                elif read_start < read_end < remaining[0] or remaining[1] < read_start < read_end or read_start > read_end:
                    new_remainings.append(remaining)
            remainings = new_remainings
        # now write to memory ranges that are not covered by handlers
        for remaining in remainings:
            _prog_read_internal(type_of_mem, remaining[0], remaining[1] - remaining[0], data[remaining[0] - address: remaining[1] - address])

    def erase(self):
        log.info("Prog: Erasing memory")
        for handler in self.handlers:
            if handler.range_start < handler.range_end:
                handler.erase(0, handler.range_end - handler.range_start)


class UserHandler():
    def __init__(self, range_start, range_end, config):
        self.range_start = range_start
        self.range_end = range_end
        self.config = config

    def call(self, address=0, data=None):
        if "handler_name" in self.config.keys():
            eval(self.config["handler_name"])()
        else:
            log.info("The name of handler function is missing")


def _prog_write(type_of_mem, address, length, data):
    global mem_handlers, live_connect
    live_connect = False
    if mem_handlers is None:
        _prog_write_internal(type_of_mem, address, length, data)
    else:
        mem_handlers.prog_write(type_of_mem, address, length, data)


def _prog_read(type_of_mem, address, length, data):
    global mem_handlers
    if mem_handlers is None:
        _prog_read_internal(type_of_mem, address, length, data)
    else:
        mem_handlers.prog_read(type_of_mem, address, length, data)


def _erase():
    global mem_handlers, erase_as_needed
    if mem_handlers is not None:
        mem_handlers.erase()
    _erase_internal()
    erase_as_needed = False  # tell prog_write not to erase rows prior to write


def init_mem_handlers():
    global mem_handlers
    mem_handlers = None
    try:
        board_file = ide.expandProjectMacros("${ProjectName}", settings.getString("loader.board_file", "${ProjectDir}/board.xboard"))
    except:
        board_file = "./board.xboard"
    if os.path.isfile(board_file):
        mem_handlers = MemHandlers(board_file)
